
## Exploiting normalization by the cache server[](https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-normalization-discrepancies/web-cache-deception/exploiting-normalization-by-the-cache-server)
If the cache server resolves encoded dot-segments but the origin server doesn't, you can attempt to exploit the discrepancy by constructing a payload according to the following structure:
```html
/<dynamic-path>%2f%2e%2e%2f<static-directory-prefix>
```

1. Run Intruder on /my-account`$;$` to find the delimeter, search for status 200, same content
2. Find how the cache server is interpreting path normalizaton
3. Build the 
> Because the origin is decoding characters, and the cache is not.  The payload path neds to be encoded and saved in the cache
#### Note

>When exploiting normalization by the cache server, encode all characters in the path traversal sequence. Using encoded characters helps avoid unexpected behavior when using delimiters, and there's no need to have an unencoded slash following the static directory prefix since the cache will handle the decoding.

In this situation, path traversal alone isn't sufficient for an exploit. For example, consider how the cache and origin server interpret the payload **`/profile%2f%2e%2e%2fstatic`**:

- The cache interprets the path as: **`/static`**
- The origin server interprets the path as: **`/profile%2f%2e%2e%2fstatic`**

The origin server is likely to return an error message instead of profile information

To exploit this discrepancy, you'll need to also identify a delimiter that is used by the origin server but not the cache. Test possible delimiters by adding them to the payload after the dynamic path
- If the origin server uses a delimiter, it will truncate the URL path and return the dynamic information.
- If the cache doesn't use the delimiter, it will resolve the path and cache the response
For example, consider the payload **`/profile;%2f%2e%2e%2fstatic`**. The origin server uses `;` as a delimiter:

- The cache interprets the path as: **`/static`**
- The origin server interprets the path as: **`/profile`**

> The origin server returns the dynamic profile information, which is stored in the cache. You can therefore use this payload for an exploit

### Detecting normalization by the cache server
Look for static files like images, javascript that are cached.

You can use a few different methods to test how the cache normalizes the path. Start by identifying potential static directories. In **Proxy > HTTP history**, look for requests with common static directory prefixes and cached responses. Focus on static resources by setting the HTTP history filter to only show messages with 2xx responses and script, images, and CSS MIME types.

You can then choose a request with a cached response and resend the request with a path traversal sequence and an arbitrary directory at the start of the static path. Choose a request with a response that contains evidence of being cached. For example, **/assets/js/stockCheck.js** to **/aaa/..%2fassets/js/stockCheck.js**

- If the response is no longer cached, this indicates that the cache isn't normalizing the path before mapping it to the endpoint. It shows that there is a cache rule based on the `/assets` prefix.
- If the response is still cached, this may indicate that the cache has normalized the path to `/assets/js/stockCheck.js`

Also add a path traversal sequence after the directory prefix. For example, modify **/assets/js/stockCheck.js** to **/assets/..%2fjs/stockCheck.js**

- If the response is no longer cached, this indicates that the cache decodes the slash and resolves the dot-segment during normalization, interpreting the path as `/js/stockCheck.js`. It shows that there is a cache rule based on the `/assets` prefix.
- If the response is still cached, this may indicate that the cache hasn't decoded the slash or resolved the dot-segment, interpreting the path as `/assets/..%2fjs/stockCheck.js`
### Confirming the folder is cache and not file extension
Note that in both cases, the response may be cached due to another cache rule, such as one based on the file extension. To confirm that the cache rule is based on the static directory, replace the path after the directory prefix with an arbitrary string. For example, `/assets/aaa`. If the response is still cached, this confirms the cache rule is based on the `/assets` prefix. Note that if the response doesn't appear to be cached, this doesn't necessarily rule out a static directory cache rule as sometimes `404` responses aren't cached.

> It's possible that you may not be able to definitively determine whether the cache decodes dot-segments and decodes the URL path without attempting an exploit.
