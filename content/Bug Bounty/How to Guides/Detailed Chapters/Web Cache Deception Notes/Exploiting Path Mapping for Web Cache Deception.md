
## Attacking Path Mapping Web Cache Deception
## **1. Check if the endpoint is vulnerable**
1. Find a page that shows sensitive information (e.g., `/myAccount`). 
2. Add an arbitrary static extension to the URL, such as:  
    `/myAccount/test.js`
 3. Send the request.
    - If you see **X-Cache: miss**, the server fetched it from origin.
4. Send the same request again.
    - If you now see **X-Cache: hit**, the response is **cacheable** and stored.
5. Verify the page loads like the original without the 'test.js' added
## **2. Create a malicious cache entry**
1. Make a **unique cache key**, for example:  
    `/myAccount;unique123.js`
2. This ensures the server creates a brand-new cache entry.
## **3. Make the victim populate the cache**
1. Host a page on your exploit server that forces the victim to visit the malicious URL.
2. When the victim loads it, **their** response (their account data) gets saved in the cache.
## **4. Retrieve the victim’s data**
1. Visit the same unique URL yourself.
2. The server returns the **cached** response containing the victim’s sensitive data.
## Payload
```html
<html>
<body>
<script>
document.location="https://website/myaccount/unique.js"
</script>
<body>
</html>
```
# Understanding Path Mapping Web Cache Deception
[Deception Cache Lab 1](https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-path-mapping-discrepancies/web-cache-deception/lab-wcd-exploiting-path-mapping)
If we identify a website that contains sensitive information we can check if its vulnerable by performing the below checks.

Verify the endpoint still loads after we add an arbitrary path to the url ie the path is 
`https://website/myAccount` try append a static file extension (e.g., `.js`, `.css`) to the abstracted URL (e.g., `/website/myAccount/foo.js`

If we see the response says ==X-Cache: miss== it means the response was made to the origin server.
We send again, if we then see ==X-Cache: hit== it means the response was cached.


## Understanding Path Mapping Discrepancies
Two common styles are traditional URL mapping and RESTful URL mapping.

Traditional URL mapping represents a direct path to a resource located on the file system. Here's a typical example:
#### Traditional URLs
`http://example.com/path/in/filesystem/resource.html`
>`http://example.com` points to the server.
 `/path/in/filesystem/` represents the directory path in the server's file system.
 `resource.html` is the specific file being accessed.

#### REST style URLs
In contrast, REST-style URLs don't directly match the physical file structure. They abstract file paths into logical parts of the API:
`http://example.com/path/resource/param1/param2`
>`http://example.com` points to the server.
> /path/resource/` is an endpoint representing a resource.
 `param1` and `param2` are path parameters used by the server to process the request.

Discrepancies in how the cache and origin server map the URL path to resources can result in web cache deception vulnerabilities. Consider the following example:

`http://example.com/user/123/profile/wcd.css`

- An origin server using REST-style URL mapping may interpret this as a request for the `/user/123/profile` endpoint and returns the profile information for user `123`, ignoring `wcd.css` as a non-significant parameter.
- A cache that uses traditional URL mapping may view this as a request for a file named `wcd.css` located in the `/profile` directory under `/user/123`. It interprets the URL path as `/user/123/profile/wcd.css`. If the cache is configured to store responses for requests where the path ends in `.css`, it would cache and serve the profile information as if it were a CSS file.
## Exploiting path mapping discrepancies
To test how the origin server maps the URL path to resources, add an arbitrary path segment to the URL of your target endpoint. If the response still contains the same sensitive data as the base response, it indicates that the origin server abstracts the URL path and ignores the added segment. For example, this is the case if modifying `/api/orders/123` to `/api/orders/123/foo` still returns order information.

To test how the cache maps the URL path to resources, you'll need to modify the path to attempt to match a cache rule by adding a static extension. For example, update `/api/orders/123/foo` to `/api/orders/123/foo.js`. If the response is cached, this indicates:

- That the cache interprets the full URL path with the static extension.
- That there is a cache rule to store responses for requests ending in `.js`.

Caches may have rules based on specific static extensions. Try a range of extensions, including `.css`, `.ico`, and `.exe`.

You can then craft a URL that returns a dynamic response that is stored in the cache. Note that this attack is limited to the specific endpoint that you tested, as the origin server often has different abstraction rules for different endpoints.